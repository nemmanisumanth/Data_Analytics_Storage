USE "SNOWFLAKE_SAMPLE_DATA"."TPCDS_SF10TCL";
select * from ITEM;

SELECT * FROM "SNOWFLAKE_SAMPLE_DATA"."TPCH_SF10"."LINEITEM";

SELECT COUNT(*) FROM "SNOWFLAKE_SAMPLE_DATA"."TPCDS_SF100TCL"."CATALOG_SALES";

CREATE DATABASE NS_INEURON_SNOWFLAKE;

USE DATABASE NS_INEURON_SNOWFLAKE;

CREATE OR REPLACE TABLE  NS_INEURON_CONSUMER_COMPLAINTS 
   (	
      DATE_RECEIVED STRING ,
      PRODUC_NAME VARCHAR2(50) , 
	  SUB_PRODUCT VARCHAR2(100) , 
	  ISSUE VARCHAR2(100), 
      SUB_ISSUE VARCHAR2(100),
      CONSUMER_COMPLAINT_NARRATIVE STRING,
      Company_Public_Response STRING,
      Company VARCHAR(80),
      State_Name CHAR(4),
      Zip_Code STRING,
      Tags VARCHAR(60),
      Consumer_Consent_Provided CHAR(20),
      Submitted_via STRING,
      Date_Sent_to_Company STRING,
      Company_Response_to_Consumer VARCHAR(80),
      Timely_Response CHAR(4),
      CONSUMER_DISPUTED CHAR(4),
      COMPLAINT_ID NUMBER(12,0) NOT NULL PRIMARY KEY
);

SELECT * FROM NS_INEURON_CONSUMER_COMPLAINTS;

SHOW COLUMNS IN NS_INEURON_CONSUMER_COMPLAINTS;

CREATE OR REPLACE TABLE NS_OWNER
(
   OwnerID INTEGER NOT NULL PRIMARY KEY ,
   Name VARCHAR2(20),
   Surname STRING,
   StreetAddress VARCHAR2(50),
   City STRING,
   State CHAR(4),
   StateFull STRING,
   ZipCode INTEGER
);

CREATE OR REPLACE TABLE NS_PETS
(
    PetID VARCHAR(10) NOT NULL PRIMARY KEY,
    Name VARCHAR(20),
    Kind STRING,
    Gender CHAR(7),
    Age INT,
    OwnerID INTEGER NOT NULL REFERENCES OWNER 
);

SELECT * FROM NS_OWNER;
SELECT * FROM NS_PETS;

SELECT * FROM NS_OWNER WHERE OWNERID IN (SELECT DISTINCT OWNERID FROM PETS);

SELECT NAME , SURNAME FROM NS_OWNER WHERE OWNERID NOT IN (SELECT DISTINCT OWNERID FROM NS_PETS WHERE KIND = 'DOG');

SELECT OWNERID,NAME FROM NS_OWNER
UNION ALL
SELECT OWNERID,NAME FROM NS_PETS;

SELECT OWNERID,NAME FROM NS_OWNER
UNION
SELECT OWNERID,NAME FROM NS_PETS;

SELECT OWNERID,NAME FROM NS_OWNER
EXCEPT
SELECT OWNERID,NAME FROM NS_PETS;

SELECT OWNERID,NAME FROM NS_OWNER
INTERSECT
SELECT OWNERID,NAME FROM NS_PETS;

SELECT COUNT(DISTINCT OWNERID) FROM NS_OWNER;
SELECT COUNT(DISTINCT PETID) FROM NS_PETS;

SELECT O.NAME AS OWNER_NAME , P.NAME AS PET_NAME , P.AGE AS PET_AGE
FROM NS_OWNER O
INNER JOIN NS_PETS P ON O.OWNERID = P.OWNERID;

SELECT O.NAME AS OWNER_NAME , P.NAME AS PET_NAME , P.AGE AS PET_AGE
FROM NS_OWNER O
LEFT OUTER JOIN NS_PETS P ON O.OWNERID = P.OWNERID;

SELECT O.NAME AS OWNER_NAME , P.NAME AS PET_NAME , P.AGE AS PET_AGE
FROM NS_OWNER O
RIGHT OUTER JOIN NS_PETS P ON O.OWNERID = P.OWNERID;

SELECT O.NAME AS OWNER_NAME , P.NAME AS PET_NAME , P.AGE AS PET_AGE
FROM NS_OWNER O
INNER JOIN NS_PETS P ON O.OWNERID = P.OWNERID;

--COUNT OF PETS EACH OWNER HAS
SELECT O.NAME AS OWNER_NAME , COUNT(DISTINCT P.PETID)
FROM NS_OWNER O
INNER JOIN NS_PETS P ON O.OWNERID = P.OWNERID
GROUP BY 1
ORDER BY 2 DESC;

--COUNT OF PETS EACH OWNER HAS
SELECT O.NAME AS OWNER_NAME , COUNT(DISTINCT P.PETID)
FROM NS_OWNER O
INNER JOIN NS_PETS P ON O.OWNERID = P.OWNERID
GROUP BY O.NAME
ORDER BY COUNT(DISTINCT P.PETID) DESC;

SELECT O.NAME AS OWNER_NAME , P.NAME AS PET_NAME , P.AGE AS PET_AGE
FROM NS_OWNER O
FULL OUTER JOIN NS_PETS P ON O.OWNERID = P.OWNERID;

SELECT DISTINCT KIND FROM NS_PETS;
SELECT KIND , COUNT(*) FROM NS_PETS
GROUP BY 1;

SELECT O.* , P.*
FROM NS_OWNER O
CROSS JOIN NS_PETS P;

SELECT * , ROW_NUMBER() OVER(ORDER BY L_COMMITDATE) AS ROW_NUM FROM "SNOWFLAKE_SAMPLE_DATA"."TPCH_SF10"."LINEITEM";

SELECT * FROM(
SELECT * , ROW_NUMBER() OVER(ORDER BY L_COMMITDATE) AS ROW_NUM FROM "SNOWFLAKE_SAMPLE_DATA"."TPCH_SF10"."LINEITEM")
WHERE ROW_NUM <= 690000;

SELECT * FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT DISTINCT
   CASE 
        WHEN (PRODUC_NAME = 'Consumer Loan') THEN 'Consumer Loan'
        WHEN (PRODUC_NAME = 'Payday loan') THEN 'Payday loan'
        WHEN (PRODUC_NAME = 'Student loan') THEN 'Student loan'
        ELSE 'Other_Financial_Servies'
        END AS LOAN_TYPE
FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT DISTINCT
           CASE
                WHEN PRODUC_NAME NOT IN ('Consumer Loan','Payday loan','Student loan') THEN 'OTHER_FINANCIAL_SERVICES'
                ELSE PRODUC_NAME
                END AS LOAN_TYPE
FROM NS_INEURON_CONSUMER_COMPLAINTS;  

SELECT * ,
           CASE
                WHEN PRODUC_NAME IN ('Consumer Loan','Payday loan','Student loan') THEN 'CSP_LOAN'
                ELSE 'OTHER_FINANCIAL_SERVICES'
                END AS LOAN_TYPE
FROM NS_INEURON_CONSUMER_COMPLAINTS;      

SELECT DISTINCT DATE_RECEIVED
FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT DISTINCT DATE_RECEIVED , SUBSTRING(DATE_RECEIVED ,7,12)
FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT DISTINCT SUBSTRING(DATE_RECEIVED ,7,12)
FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT EXTRACT(YEAR FROM (to_date(DATE_RECEIVED,'dd-mm-yyyy'))) FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT DISTINCT(EXTRACT(YEAR FROM (to_date(DATE_RECEIVED,'dd-mm-yyyy')))) FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT DISTINCT(EXTRACT(MONTH FROM (to_date(DATE_RECEIVED,'dd-mm-yyyy')))) FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT DISTINCT(EXTRACT(DAY FROM (to_date(DATE_RECEIVED,'dd-mm-yyyy')))) FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT COUNT(DISTINCT DATE_RECEIVED)
FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT DISTINCT(EXTRACT(MONTH FROM (to_date(DATE_RECEIVED,'dd-mm-yyyy')))) FROM NS_INEURON_CONSUMER_COMPLAINTS;

SELECT * ,
         CASE
            WHEN (to_date(DATE_RECEIVED,'dd-mm-yyyy')>= '2013-01-01' AND to_date(DATE_RECEIVED,'dd-mm-yyyy')<= '2013-12-31') THEN 'PPR12 PERIOD'
            WHEN (to_date(DATE_RECEIVED,'dd-mm-yyyy')>= '2014-01-01' AND to_date(DATE_RECEIVED,'dd-mm-yyyy')<= '2014-12-31') THEN 'PR12 PERIOD'
            WHEN (to_date(DATE_RECEIVED,'dd-mm-yyyy')>= '2015-01-01' AND to_date(DATE_RECEIVED,'dd-mm-yyyy')<= '2015-12-31') THEN 'R12 PERIOD'
            END AS TXN_PERIOD
FROM NS_INEURON_CONSUMER_COMPLAINTS;

-- sql date functions

-- GET CURRENT DATE
SELECT CURRENT_DATE;

-- GET CURRENT TIMESTAMP
SELECT CURRENT_TIMESTAMP;

-- GET CURRENT TIME
SELECT CURRENT_TIME;



-- CONVERT TIMEZONE
SELECT CONVERT_TIMEZONE('UTC',CURRENT_TIMESTAMP) AS UTC_TIMEZONE;

-- CONVERT DATE TO SUBSEQUENT 4 MONTHS AHEAD
SELECT ADD_MONTHS(CURRENT_DATE,4) as DATE_AFTER_4_MONTHS;

-- 3 MONTHS BACK DATE
SELECT TO_CHAR(ADD_MONTHS(CURRENT_DATE,-3),'DD-MM-YYYY') as DATE_BEFORE_3_MONTHS;

-- GET YR FROM DATE
SELECT DATE_TRUNC('YEAR',CURRENT_DATE) AS YR_FROM_DATE;

-- GET MTH FROM DATE
SELECT DATE_TRUNC('MONTH',CURRENT_DATE) AS MTH_FROM_DATE;

-- GET DAY FROM DATE
SELECT DATE_TRUNC('DAY',CURRENT_DATE) AS DAY_FROM_DATE;

-- GET LAST DAY OF current MONTH
select last_day(current_date) as last_day_curr_month;

-- GET LAST DAY OF PREVIOUS MONTH
SELECT LAST_DAY(CURRENT_DATE - INTERVAL '1 MONTH') AS LAST_DAY_PREV_MNTH;

SELECT LAST_DAY(CURRENT_DATE - INTERVAL '2 MONTH') + INTERVAL '1 DAY' AS FIRST_DAY;

SELECT QUARTER(CURRENT_DATE) AS QTR;

SELECT EXTRACT(YEAR FROM CURRENT_DATE) AS YR;
SELECT EXTRACT(MONTH FROM CURRENT_DATE) AS MTH;
SELECT EXTRACT(DAY FROM CURRENT_DATE) AS DAY;

select QUARTER(to_date('2022-08-24'));

SELECT to_date('08-23-2022','mm-dd-yyyy');

SELECT TO_CHAR('08-23-2022','MM-DD-YYYY');

SELECT TO_DATE('1993-08-17') AS DATE;

SELECT TO_CHAR(TO_DATE('1993-08-17'),'DD-MM-YYYY') AS DATE_DD_MM_YYYY;

SELECT TO_CHAR(TO_DATE('1993-08-17'),'MM-YYYY') AS DATE_MM_YYYY;

SELECT TO_CHAR(TO_DATE('1993-08-17'),'MON-YYYY') AS DATE_MON_YYYY;

SELECT TO_CHAR(TO_DATE('1993-08-17'),'MON-YY') AS DATE_MON_YY;

SELECT TO_CHAR(TO_DATE('1993-08-17'),'DY') AS DATE_DAY;

SELECT DAYNAME ('1993-08-23');

SELECT TO_CHAR(TO_DATE('1993-08-17'),'YYYY-DD') AS DATE;

SELECT TO_CHAR(TO_DATE('1993-08-17'),'DD-MM') AS DATE;

select MONTH(CURRENT_DATE);
SELECT EXTRACT(MONTH FROM CURRENT_DATE) AS MTH;

SELECT ADD_MONTHS(CURRENT_DATE,-3) AS DATE_3_MNTHS_BACK;
SELECT ADD_MONTHS(CURRENT_DATE,5) AS DATE_5_MNTHS_AHEAD;

select datediff('day', '2022-06-01',CURRENT_DATE);
select datediff('day', '2022-07-23','2023-07-19');

select datediff('MONTH', '2021-06-01',CURRENT_DATE);
select datediff('YEAR', '2014-06-01',CURRENT_DATE);

select dateadd('day',-23,'2022-06-01');
select dateadd('month',-2,'2022-06-01');
select dateadd('year',-5,'2022-06-01');

select WEEK(CURRENT_DATE); -- FROM 1ST JAN 2022 HOW MNAY EEKS HAVE SURPASSED
select MONTH(CURRENT_DATE); -- -- FROM 1ST JAN 2022 HOW MNAY MONTHS HAVE SURPASSED
select YEAR(CURRENT_DATE); ---- 

select datediff('MONTH', '2022-06-01',CURRENT_DATE);
select datediff('YEAR', '2014-06-01',CURRENT_DATE);

SELECT DATE_TRUNC('DAY',CURRENT_DATE) AS DAY_FROM_DATE;

SELECT * FROM OWNER; -- 89 ROWS
SELECT * FROM PETS;-- 100 ROWS

--SUBQUERY
SELECT * FROM OWNER WHERE OWNERID IN (SELECT DISTINCT OWNERID FROM PETS);

SELECT NAME,SURNAME FROM OWNER WHERE OWNERID NOT IN (SELECT DISTINCT OWNERID FROM PETS WHERE KIND = 'Dog');




-- UNION ALL
SELECT OWNERID,NAME FROM OWNER
UNION ALL
SELECT OWNERID,NAME FROM PETS;

--EXCEPT CLAUSE
SELECT OWNERID,NAME FROM OWNER
EXCEPT
SELECT OWNERID,NAME FROM PETS;

--INTERSECT
SELECT OWNERID,NAME FROM OWNER
INTERSECT
SELECT OWNERID,NAME FROM PETS;

SELECT COUNT(DISTINCT OwnerID) from OWNER;
SELECT COUNT(DISTINCT PetID) from PETS;

-- NEED THE NAME OF OWNER & THEIR DOGS NAME ALONG WITH THEIR AGE  ---- INNER JOIN
SELECT O.Name AS OWNER_NAME,p.NAME AS PET_NAME,p.age AS PET_AGE
FROM OWNER o
INNER JOIN PETS p ON o.OwnerID = p.OwnerID;

--NEED THE NAME OF ALL THE OWNERS IRRESPECTIVE WETHER OR NOT THEY ARE HAVING PETS 
SELECT O.Name AS OWNER_NAME,p.NAME AS PET_NAME,p.age AS PET_AGE
FROM OWNER o
LEFT OUTER JOIN PETS p ON o.OwnerID = p.OwnerID;

--- COUNT OF PETS EACH OWNER HAS
SELECT O.Name AS OWNER_NAME,COUNT(DISTINCT p.PETID)
FROM OWNER o
INNER JOIN PETS p ON o.OwnerID = p.OwnerID
GROUP BY 1
ORDER BY 2 DESC;

---RIGHT JOIN
SELECT O.Name AS OWNER_NAME,p.NAME AS PET_NAME,p.age AS PET_AGE
FROM OWNER o
RIGHT JOIN PETS p ON o.OwnerID = p.OwnerID;

--FULL OUTER JOIN
SELECT O.*,P.*
FROM OWNER O
FULL OUTER JOIN PETS p ON o.OwnerID = p.OwnerID;

-- INFO OF ALL THE PETS HOLD BY THEIR OWNER
SELECT DISTINCT KIND FROM PETS;
SELECT KIND,COUNT(*) FROM PETS
GROUP BY 1;

--- CROSS JOIN 
SELECT O.*,P.*
FROM OWNER O
CROSS JOIN PETS p ;

------------------------

CREATE OR REPLACE TABLE EMPLOYEE
(
   EMPID INTEGER NOT NULL PRIMARY KEY,
   EMP_NAME VARCHAR2(20),
   JOB_ROLE STRING,
   SALARY NUMBER(10,2)
);

INSERT INTO EMPLOYEE
VALUES('101','ANAND JHA','Analyst',50000);

INSERT INTO EMPLOYEE
VALUES(102,'ALex', 'Data Enginner',60000);

INSERT INTO EMPLOYEE
VALUES(103,'Ravi', 'Data Scientist',48000);

INSERT INTO EMPLOYEE
VALUES(104,'Peter', 'Analyst',98000);

INSERT INTO EMPLOYEE
VALUES(105,'Pulkit', 'Data Scientist',72000);

INSERT INTO EMPLOYEE
VALUES(106,'Robert','Analyst',100000);

INSERT INTO EMPLOYEE
VALUES(107,'Rishabh','Data Engineer',67000);

INSERT INTO EMPLOYEE
VALUES(108,'Subhash','Manager',148000);

INSERT INTO EMPLOYEE
VALUES(109,'Michaeal','Manager',213000);

INSERT INTO EMPLOYEE
VALUES(110,'Dhruv','Data Scientist',89000);

INSERT INTO EMPLOYEE
VALUES(111,'Amit Sharma','Analyst',72000);

DELETE FROM EMPLOYEE WHERE EMPID = 110;

SELECT * FROM EMPLOYEE;

update employee set job_role='Data Engineer'
where empid=102;

update employee set salary= 50000
where empid=104;
  
  
  
 
-------------------------------------------------------------WINDOW FUNCTIONS------------------------------------------------------------

-- SYNTAX : window_function_name(<exprsn>) OVER (<partition_by_clause> <order_clause>)

--- display total salary based on job profile
SELECT JOB_ROLE,SUM(SALARY) FROM EMPLOYEE 
GROUP BY JOB_ROLE;

-- display total salary along with all the records ()every row value 
SELECT * , SUM(SALARY) OVER() AS TOT_SALARY
FROM EMPLOYEE;

-- display the total salary per job category for all the rows 
SELECT *,MAX(SALARY) OVER(PARTITION BY JOB_ROLE) AS MAX_JOB_SAL
FROM EMPLOYEE;

select *,max(salary) over(partition by JOB_ROLE) as MAX_SAL , 
min(salary) over(partition by JOB_ROLE) as MIN_SAL,
SUM(salary) over(partition by JOB_ROLE) as TOT_SAL
from Employee;



--ARRANGING ROWS WITHIN EACH PARTITION BASED ON SALARY IN DESC ORDDER
select *,max(salary) over(partition by JOB_ROLE ORDER BY SALARY DESC) as MAX_SAL , 
min(salary) over(partition by JOB_ROLE ORDER BY SALARY DESC) as MIN_SAL,
SUM(salary) over(partition by JOB_ROLE ORDER BY SALARY DESC) as TOT_SAL
from Employee;


-- ROW_NUMBER() It assigns a unique sequential number to each row of the table ...
SELECT * FROM 
(
SELECT *,ROW_NUMBER() OVER(PARTITION BY JOB_ROLE ORDER BY SALARY DESC) AS PART_ROW_NUM 
FROM EMPLOYEE 
)
WHERE PART_ROW_NUM <=2;

SELECT *,ROW_NUMBER() OVER(PARTITION BY JOB_ROLE ORDER BY COUNT(2) DESC ) AS PART_ROW_NUM 
FROM EMPLOYEE ;

/* The RANK() window function, as the name suggests, ranks the rows within their partition based on the given condition.
   In the case of ROW_NUMBER(), we have a sequential number. 
   On the other hand, in the case of RANK(), we have the same rank for rows with the same value.
But there is a problem here. Although rows with the same value are assigned the same rank, the subsequent rank skips the missing rank. 
This wouldn’t give us the desired results if we had to return “top N distinct” values from a table. 
Therefore we have a different function to resolve this issue. */

SELECT *,ROW_NUMBER() OVER(PARTITION BY JOB_ROLE ORDER BY SALARY DESC) AS ROW_NUM ,
RANK() OVER(PARTITION BY JOB_ROLE ORDER BY SALARY DESC) AS RANK_ROW
FROM EMPLOYEE;

/* The DENSE_RANK() function is similar to the RANK() except for one difference, it doesn’t skip any ranks when ranking rows
Here, all the ranks are distinct and sequentially increasing within each partition. 
As compared to the RANK() function, it has not skipped any rank within a partition. */

SELECT * FROM 
(
SELECT *,ROW_NUMBER() OVER(PARTITION BY JOB_ROLE ORDER BY SALARY) AS ROW_NUM ,
RANK() OVER(PARTITION BY JOB_ROLE ORDER BY SALARY) AS RANK_ROW,
DENSE_RANK() OVER(PARTITION BY JOB_ROLE ORDER BY SALARY) AS DENSE_RANK_ROW 
FROM EMPLOYEE  
)
WHERE DENSE_RANK_ROW <=2;

CREATE OR REPLACE TABLE  NS_INEURON_CONSUMER_COMPLAINTS1 
   (	
      DATE_RECEIVED STRING ,
      PRODUC_NAME VARCHAR2(50) , 
	  SUB_PRODUCT VARCHAR2(100) , 
	  ISSUE VARCHAR2(100), 
      SUB_ISSUE VARCHAR2(100),
      CONSUMER_COMPLAINT_NARRATIVE STRING,
      Company_Public_Response STRING,
      Company VARCHAR(80),
      State_Name CHAR(4),
      Zip_Code STRING,
      Tags VARCHAR(60),
      Consumer_Consent_Provided CHAR(20),
      Submitted_via STRING,
      Date_Sent_to_Company STRING,
      Company_Response_to_Consumer VARCHAR(80),
      Timely_Response CHAR(4),
      CONSUMER_DISPUTED CHAR(4),
      COMPLAINT_ID NUMBER(12,0) NOT NULL PRIMARY KEY
);

CREATE OR REPLACE TABLE NS_CONSUM_COMPLAINTS_COPY AS
SELECT * FROM NS_INEURON_CONSUMER_COMPLAINTS;

CREATE OR REPLACE TABLE CONSUM_COMPLAINTS_AWS LIKE NS_INEURON_CONSUMER_COMPLAINTS;
SHOW COLUMNS IN CONSUM_COMPLAINTS_AWS;

SELECT * FROM NS_CONSUM_COMPLAINTS_COPY;

SELECT * FROM CONSUM_COMPLAINTS_AWS;

##### LAODING A FILE FROM EXTERNAL STAGE - AWS ##########

CREATE OR REPLACE TABLE CONSUM_COMPLAINTS_AWS LIKE CONSUM_COMPLAINTS;
SHOW COLUMNS IN CONSUM_COMPLAINTS_AWS;

--list stage confirm if its empty
LIST @AWS_CONSUMER_COMPLAINTS;

----list stage confirm if its empty
LIST @AZURE_STORAGE;

##### LOADING A FILE FROM EXTERNAL STAGE - AZURE ##########
CREATE OR REPLACE TABLE CONSUM_COMPLAINTS_AZURE LIKE CONSUM_COMPLAINTS;
SHOW COLUMNS IN CONSUM_COMPLAINTS_AZURE;

--COPYING INTO AZURE STORAGE SERVICE
COPY INTO CONSUM_COMPLAINTS_AZURE FROM @AZURE_STORAGE
FILE_FORMAT = (TYPE = CSV FIELD_DELIMITER = ',' SKIP_HEADER = 1)
PURGE = TRUE;

--BINGO
SELECT * FROM CONSUM_COMPLAINTS_AZURE;

--REMOVE FILES
REMOVE @AWS_CONSUMER_COMPLAINTS;


--##COPYING INTO STORAGE SERVICE
COPY INTO CONSUM_COMPLAINTS_AWS FROM @AWS_CONSUMER_COMPLAINTS
FILE_FORMAT = (TYPE = CSV FIELD_DELIMITER = ',' SKIP_HEADER = 1)
PURGE = TRUE;

--BINGO DONE....
SELECT * FROM CONSUM_COMPLAINTS_AWS;

--Data Pipelining
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------

create table patients
(
  PATIENTID INT,
  FIRST_NAME VARCHAR(100),
  CITY VARCHAR(100),
  REGISTRATIONYEAR INT
);

--First create bucket -> create user -> create policy(bucket policy) -> attach user and policy -> create access key -> then create staging area as per below

--create the stage
create or replace stage PATIENTS_SNOW_STAGE
url = 's3://patient-data-snow-pipe' -- name of the bucket which you have created
credentials = (aws_key_id = 'AKIA3CUCCXNW25KRJD3R' aws_secret_key = '6jyUgzn0sCqhfqOw39jKIfIlba00GucfUFRECnnc')
file_format = CSV;

SHOW STAGES;

--CREATE SNOWPIPE THAT RECOGNISES CSV THAT ARE INGESTED FROM EXTERNAL STAGE AND COPIES THE DATA INTO PATIENTS TABLE
--The AUTO_INGEST=true parameter specifies to read event notifications sent from an S3 bucket to an SQS queue when new data is ready to load.

CREATE OR REPLACE PIPE PATIENTS_SNOWPIPE AUTO_INGEST = TRUE AS
COPY INTO patients
FROM @PATIENTS_SNOW_STAGE
FILE_FORMAT = CSV;

--Then go to bucket -> go to properties -> create event notification (for arn go to snowflake -> quiery (show pipes;) copy arn from notification_channel in result) -> sve changes

SHOW PIPES;

SELECT * FROM PATIENTS;
select count(*) from patients;

alter pipe PATIENTS_SNOWPIPE refresh;

select system$pipe_status('PATIENTS_SNOWPIPE');


USE SNOWFLAKE_PIPELINE;

--CREATE STORAGE INTEGRATION OBJECT
CREATE OR REPLACE STORAGE INTEGRATION  aws_s3_snowpipe_integration
TYPE = EXTERNAL_STAGE
STORAGE_PROVIDER = S3
ENABLED = TRUE
STORAGE_AWS_ROLE_ARN = 'arn:aws:iam::761555762029:role/aws-s3-snowpipe-role'
STORAGE_ALLOWED_LOCATIONS = ('s3://aws-s3-snowpipe')
COMMENT = 'Integration with aws s3 bucket';

--GET EXTERNAL_ID AND UPDATE IT IN S3
DESC INTEGRATION aws_s3_snowpipe_integration;

CREATE OR REPLACE STAGE aws_s3_snowpipe_stage
url = 's3://aws-s3-snowpipe' --name of the bucket which was created
--credentials = (aws_key_id = 'AKIA3CUCCXNWRVCZ3UER' aws_secret_key = 'nv8ApsdcNnx5DYeV3IM9cjhshn2P9QR0F3GQQESn') -->NOT REQUIRED
file_format = CSV
storage_integration = aws_s3_snowpipe_integration;

// Create file format object
CREATE OR REPLACE file format CSV
    type = csv
    field_delimiter = ','
    skip_header = 1
    empty_field_as_null = TRUE;

//Listing files under your s3 buckets
list @aws_s3_snowpipe_stage;

drop table healthcare;
CREATE OR REPLACE TABLE HEALTHCARE(
Patientid int,	
gender CHAR(8),	
age int	,
hypertension int,	
heart_disease int,	
ever_married CHAR(30),	
work_type VARCHAR(60),	
Residence_type CHAR(30)	,
avg_glucose_level int,	
bmi VARCHAR(20)	,
smoking_status	VARCHAR(20),
stroke int
);

// Create a pipe
CREATE OR REPLACE pipe aws_s3_snowpipe_pipe
AUTO_INGEST = TRUE
AS
COPY INTO healthcare
FROM @aws_s3_snowpipe_stage
FILE_FORMAT = (type = CSV);

// Describe pipe to get ARN
DESC pipe aws_s3_snowpipe_pipe;

// Get Notification channel ARN and update the same in event notifications SQS queue

// Use Copy command to load the files
COPY INTO  healthcare
    FROM @aws_s3_snowpipe_stage
    FILE_FORMAT = (Type = CSV) ON_ERROR= CONTINUE;

select * from healthcare;

